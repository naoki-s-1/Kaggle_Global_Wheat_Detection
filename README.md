# Kaggle_Global_Wheat_Detection
Global Wheat Detectionコンペの記録

![](https://storage.googleapis.com/kaggle-media/competitions/UofS-Wheat/descriptionimage.png)

### データセットの説明
データ取得とプロセスの詳細については、https://arxiv.org/abs/2005.02162 をご覧ください

データ形式はどうなると思いますか?
データは小麦畑の画像であり、識別された各小麦の頭に境界ボックスがあります。すべての画像に小麦の頭/バウンディングボックスが含まれているわけではありません。画像は世界中の多くの場所で記録されました。

CSV データは単純です - 画像 ID は特定の画像のファイル名と一致し、画像の幅と高さがバウンディングボックス (以下を参照) と共に含まれます。各バウンディング ボックスには の行があります。すべての画像にバウンディングボックスがあるわけではありません。train.csv

ほとんどのテストセット画像は非表示になっています。テスト画像の小さなサブセットは、コードの記述に使用するために含まれています。

私は何を予測しているのか?
各小麦の頭の周りの境界ボックスを、それらを含む画像で予測しようとしています。小麦の頭がない場合は、バウンディング ボックスがないと予測する必要があります。

#### ファイル  
- train.csv - トレーニングデータ  
- sample_submission.csv - 正しい形式のサンプル提出ファイル  
- train.zip - トレーニング画像  
- test.zip - テストイメージ  

#### 列  
- image_id- 一意の画像 ID  
- width, - 画像の幅と高さheight  
- bbox- Python スタイルの [xmin, ymin, width, height] のリストとして書式設定されたバウンディングボックス  
- 等。

### 2024-08-11 日曜日
yolov5を使ってテストしたがsubmission.csvがうまく作成されず提出できなかった

### 2024-08-12 月曜日
- ImageOps.fit 関数の構造
  - ImageOps.fit 関数は、Pillowライブラリに含まれる ImageOps モジュールのメソッドで、指定された画像を指定のサイズに収めるためにリサイズする機能を持っています。この処理では、アスペクト比（縦横比）を保持しつつ、画像の中央部分が希望のサイズに収まるようにトリミングされます。

### 2024-08-14 水曜日
チャットGPTを駆使するも複雑でベースモデルのサブミットまでたどり着けず。

### 2024-08-16 金曜日
進展なし

### 2024-08-17 土曜日
#### 便利な関数
- 文字列表現をPythonのオブジェクトに変換する  
  import ast ライブラリ
  df.bbox=df.bbox.apply(lambda x: ast.literal_eval(x)): 使用例    

- ast.literal_eval(x):
  - これは ast モジュール（Abstract Syntax Treesの略）に含まれる literal_eval 関数です。
literal_eval は、文字列で表現されたPythonリテラルを、実際のPythonオブジェクト（リスト、タプル、辞書など）に変換します。通常、文字列が安全に評価されることを保証するために使用されます。
例えば、x が "[1, 2, 3, 4]" のような文字列の場合、ast.literal_eval(x) はこれを実際のリスト [1, 2, 3, 4] に変換します。
- numpyを使ったbboxの要素の分割
  - bbox = np.stack(df['bbox'].apply(lambda x: np.fromstring(x[1:-1], sep=',')))
  - array([[834., 222.,  56.,  36.],  
           [226., 548., 130.,  58.],  
           [377., 504.,  74., 160.],  
           ...,  
           [134., 228., 141.,  71.],  
           [430.,  13., 184.,  79.],  
           [875., 740.,  94.,  61.]])

- CV予測をする際に役立ちそうだった  
gfk = GroupKFold(n_splits=4)  
for fold, (_, va_idx) in enumerate(gfk.split(X=df, y=df['source'],  
                                                  groups=df['image_id']),  
                                   start=1):  
    df.loc[va_idx, 'fold'] = fold  

### 2024-08-18 日曜日
ようやく提出までたどり着けた！
![image](https://github.com/user-attachments/assets/9c080e20-ae42-4405-afc8-1e2acfdf1620)  
とりあえずこのスコアをベースにして進めていく

### 2024-08-20 火曜日
#### 物体検出の出力について
##### データセットの作成
   ![image](https://github.com/user-attachments/assets/d4400ce4-b197-4648-9239-b2232dd7bcab)

- batch_size: 各バッチに含めるデータの数を指定します。batch_sizeはバッチサイズの整数値です。
   
- padding_values: 各テンソルのパディングに使う値を指定します。この引数には、データセット内の各テンソルに対して異なるパディング値を設定することができます。

  - (0.0, 1e-8, -1)は、データセットの各要素が3つの異なるテンソル（または3つの異なる次元）から構成されている場合の例です。  
      各テンソルに対するパディング値を0.0、1e-8、-1と指定しています。
  - 例: 1つ目のテンソルが画像データで、2つ目のテンソルが正規化されたバウンディングボックスの座標、3つ目のテンソルがラベルを表す場合、  
      それぞれに異なるパディング値を適用することができます。
- drop_remainder: Trueの場合、データセット内で最後のバッチがbatch_sizeに満たない場合、そのバッチをドロップします。Falseの場合、バッチサイズに満たない最後のバッチも返します。

  ##### モデルの出力について

1. 固定サイズの出力を使用する
  - 概要: 予測するバウンディングボックスの最大数を事前に決定し、その固定数でモデルの出力を設計します。
     この場合、すべての画像で同じ数のバウンディングボックスを予測し、必要に応じて不要なバウンディングボックスは無視されます。

  - 形状: (#バッチサイズ, #固定バウンディングボックス数, 4 + #クラス数)のテンソルになります。

    - 4はバウンディングボックスの座標（中心x, 中心y, 幅, 高さ）を表します。
    - #クラス数は分類するクラスの数です。
  - 欠点: 固定された最大バウンディングボックス数より少ない場合は計算が無駄になり、  
    多すぎる場合は重要なオブジェクトが見逃される可能性があります。

2. マスクとパディングを使用する
     
  - 概要: 画像ごとのバウンディングボックス数が異なることを考慮して、出力を固定サイズにしつつ、
     不要なバウンディングボックスには特定のマスクやパディングを適用します。
     例えば、無効なバウンディングボックスのラベルを特定の値（例: -1）でパディングし、損失計算時に無視します。

  - 形状: (#バッチサイズ, #最大バウンディングボックス数, 4 + #クラス数)。

    - #最大バウンディングボックス数は、データセット内の画像に対する最大のバウンディングボックス数です。
    - 各画像のバウンディングボックスの数がこれに満たない場合、残りの部分をパディングで埋めます。
3. 動的出力を使用する
     
  - 概要: 出力の形状をバッチ内の各画像ごとに異なるサイズにすることは一般的には難しいため、
     全ての画像に対して動的に異なる数のバウンディングボックスを出力するモデルはあまり一般的ではありません。
     しかし、ネットワークの特定の部分で可変長の出力が可能なように設計することは可能です。
  - 形状: 各画像ごとに異なる数のバウンディングボックスを持つテンソルが出力されます。
     具体的には、ネットワークの出力後に、非最大抑制 (NMS) やスコアのしきい値を用いて、実際の検出を動的に行います。
  - 例: YOLOやSSDなどのモデルは、事前定義されたアンカーボックスに基づいて、  
    固定された多数の候補を出力しますが、最終的に必要な数だけを選択します。
    
4. シーケンス出力として扱う
     
  - 概要: バウンディングボックスの出力をシーケンスのように扱い、変動する数の出力を生成する方法もあります。
     この場合、各シーケンスの長さはバウンディングボックスの数に対応します。
  - 形状: 各バッチの形状は(バッチサイズ, 最大シーケンス長, 4 + クラス数)になります。シーケンスの長さに応じて、シーケンス内の一部をマスクすることが可能です。
5. アンカーボックスを使用する
     
  - 概要: アンカーボックスを用いて、異なるスケールやアスペクト比を持つ多数のバウンディングボックス候補を生成し、その中から最適なものを選ぶアプローチです。
     この方法では、各アンカーに対して出力を予測し、不要なものは後処理で除外します。
  - 形状: アンカーボックスに基づく出力は、(#バッチサイズ, #アンカーボックス数, 4 + #クラス数)となります。 
